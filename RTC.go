//WebRTC-Broadcast Â© Albert Bregonia 2021
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/pion/rtcp"
	"github.com/pion/webrtc/v3"
)

// Main handler for creating/managing a WebSocket/WebRTC PeerConnection

var (
	peers    = make([]*webrtc.PeerConnection, 0)
	peersMtx = sync.Mutex{}
)

func AddPeer(peer *webrtc.PeerConnection) {
	peersMtx.Lock()
	defer peersMtx.Unlock()
	peers = append(peers, peer)
}

func RemovePeer(peer *webrtc.PeerConnection) {
	peersMtx.Lock()
	defer peersMtx.Unlock()
	for i := range peers {
		if peers[i] == peer {
			peer.Close()
			peers = append(peers[:i], peers[i+1:]...)
			return
		}
	}
}

func SignalingServer(w http.ResponseWriter, r *http.Request) {
	if e := ConnectionHandler(w, r); e != nil {
		log.Println(e)
	}
}

func ConnectionHandler(w http.ResponseWriter, r *http.Request) error {
	//create a thread safe websocket for signaling with JavaScript
	ws, e := wsUpgrader.Upgrade(w, r, nil)
	if e != nil {
		http.Error(w, e.Error(), http.StatusBadRequest)
		return e
	}
	signaler := SignalingSocket{ws, sync.Mutex{}}
	defer signaler.Close()

	//create the WebRTC peer connection that will broadcast the remote stream to everyone
	peer, e := api.NewPeerConnection(config)
	if e != nil {
		return e
	}
	AddPeer(peer)
	defer RemovePeer(peer)
	if _, e := peer.AddTrack(whiteboard); e != nil {
		return e
	}

	peer.OnConnectionStateChange(
		func(pcs webrtc.PeerConnectionState) { log.Println(`peer connection state:`, pcs.String()) })
	peer.OnICEConnectionStateChange(
		func(is webrtc.ICEConnectionState) { log.Println(`ice connection state:`, is.String()) })
	peer.OnICECandidate(func(ice *webrtc.ICECandidate) {
		if ice == nil {
			return
		}
		iceJS, _ := json.Marshal(ice.ToJSON()) //error is ignored as the struct is generated by WebRTC
		if e := signaler.SendSignal(Signal{`ice`, string(iceJS)}); e != nil {
			signaler.Close()
		}
	})

	//every time we get packets, send those packets to the whiteboard broadcast
	peer.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
		var lastTimestamp uint32 = 0
		keyframePeriod := 500 * time.Millisecond
		lastKeyframe := time.Now().Add(-keyframePeriod)
		for {
			packet, _, e := track.ReadRTP()
			if e != nil {
				return
			}
			if time.Since(lastKeyframe) >= keyframePeriod {
				peersMtx.Lock()
				for _, peer := range peers { //force everyone to refresh
					if peer.WriteRTCP([]rtcp.Packet{
						&rtcp.PictureLossIndication{MediaSSRC: uint32(track.SSRC())}}) != nil {
						return
					}
				}
				peersMtx.Unlock()
			}
			oldTimestamp := packet.Timestamp //save the actual packet timestamp
			if lastTimestamp == 0 {
				packet.Timestamp = 0
			} else { //packet timestamps have been modified to be the change in time since the last frame
				packet.Timestamp -= lastTimestamp
			}
			lastTimestamp = oldTimestamp
			whiteboardPackets <- packet
		}
	})

	if e := signaler.SendSignal(Signal{`offer-request`, `{}`}); e != nil {
		return e
	}
	signal := Signal{}
	for {
		if e := signaler.ReadJSON(&signal); e != nil {
			return e
		}
		switch signal.Event {
		case `ice`:
			candidate := webrtc.ICECandidateInit{}
			if e := json.Unmarshal([]byte(signal.Data), &candidate); e != nil {
				return e
			}
			if e := peer.AddICECandidate(candidate); e != nil {
				return e
			}
		case `answer`:
			answer := webrtc.SessionDescription{}
			if e := json.Unmarshal([]byte(signal.Data), &answer); e != nil {
				return e
			}
			if e := peer.SetRemoteDescription(answer); e != nil {
				return e
			}
		case `offer`:
			offer := webrtc.SessionDescription{}
			if e := json.Unmarshal([]byte(signal.Data), &offer); e != nil {
				return e
			}
			if e := peer.SetRemoteDescription(offer); e != nil {
				return e
			}
			answer, e := peer.CreateAnswer(nil)
			if e != nil {
				return e
			}
			if e := peer.SetLocalDescription(answer); e != nil {
				return e
			}
			answerJS, _ := json.Marshal(answer)
			if e := signaler.SendSignal(Signal{`answer`, string(answerJS)}); e != nil {
				return e
			}
		}
	}
}
